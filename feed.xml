<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://njcolvin.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://njcolvin.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-09-21T21:03:17+00:00</updated><id>https://njcolvin.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Recursion</title><link href="https://njcolvin.github.io/blog/2023/divide-and-conquer/" rel="alternate" type="text/html" title="Recursion"/><published>2023-03-05T00:00:00+00:00</published><updated>2023-03-05T00:00:00+00:00</updated><id>https://njcolvin.github.io/blog/2023/divide-and-conquer</id><content type="html" xml:base="https://njcolvin.github.io/blog/2023/divide-and-conquer/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>This note assumes you know what an algorithm is, but as a quick refresher according to Jeff Erickson, “an algorithm is an explicit, precise, unambiguous, mechanically-executable sequence of elementary instructions, usually intended to accomplish a specific purpose.”<d-cite key="erickson2019Algos"></d-cite></p> <p>Good algorithms are incredibly useful, but sometimes a problem might not have a clear algorithmic solution. Worse, it might even be <a href="https://en.wikipedia.org/wiki/Undecidable_problem">impossible</a>. A powerful method to solve an unknown problem is to make a <strong>reduction</strong> to one or more simpler problems that can be solved by known algorithms. The reduction of a problem can even be into smaller instances of itself, breaking up repeatedly until reaching one of several base cases. This is called <strong>recursion</strong>. Divide-and-conquer is a general pattern for solving a problem using recursion:</p> <ol> <li><strong>Divide</strong> the problem into independent smaller instances of the same problem.</li> <li><strong>Conquer</strong> or solve the smaller instances by recursion.</li> <li><strong>Combine</strong> the solutions of the smaller instances into a solution of the original problem.</li> </ol> <p>It is often easier to think of recursion without thinking about solving the smaller subproblems yourself. Instead, think of a worker solving all of the subproblems for you. You must know how to relate the problem to smaller versions of itself, and how to solve any of the smallest instances that can no longer be simplified. Once you simplify the original problem, hand the subproblems off to the worker. They will simplify and solve the subproblems for you, so let them work in peace.</p> <p>A natural way to characterize the running time of a divide-and-conquer algorithm is to use a <strong>recurrence</strong>, or a function defined in terms of itself. So far we have been using the words <em>smaller</em> and <em>simpler</em> interchangably. Indeed, in terms of analyzing the running time of an algorithm we often consider the input size, denoted \(n\).</p> <p>As a quick example, consider the following recurrence for merge sort:</p> \[MergeSort(n) = \begin{cases} \Theta(1) &amp; n = 1 \\ 2MergeSort(n/2) + \Theta(n) &amp; otherwise \end{cases}\] <p>Merge sort consists of splitting the unsorted input array into two roughly equal halves, recursively sorting those halves, and then merging the sorted halves into a sorted version of the input array. The recurrence says it takes constant \(\Theta(1)\) time to sort an array with 1 element, or \(2MergeSort(n/2)\) time to sort the halves and linear \(\Theta(n)\) time to merge the halves into a solution. It is well-documented the overall running time is \(\Theta(n \log{n})\).</p> <hr/> <h2 id="the-substitution-method">The Substitution Method</h2> <p>Consider a similar recurrence:</p> \[T(n) = 2T(\lfloor{n/2}\rfloor) + n\] <p>This has the same asymptotic complexity as merge sort because in general floors, ceilings, and even lower order terms can be removed entirely from divide and conquer recurrences using domain transformations. So since we know it’s like merge sort, how do we show \(T(n) = O(n \log{n})\)? Using the definition of <a href="https://en.wikipedia.org/wiki/Big_O_notation">big O</a>, we must show there exist positive constants \(c\) and \(n_0\) such that:</p> \[T(n) \leq cn\lg{n}, \quad n \geq n_0\] <p>where \(\lg{n} = \log_2{n}\). To do this, we must assume the above inequality holds for some positive \(m &lt; n\), particularly \(m = \lfloor{n/2}\rfloor\). Plugging this in gives:</p> \[\begin{flalign} T(n) &amp; \leq 2(c\lfloor{n/2}\rfloor\lg{\lfloor{n/2}\rfloor}) + n&amp;\\ &amp; \leq cn\lg{n/2} + n&amp;\\ &amp; = cn\lg{n} - cn\lg{2} + n&amp;\\ &amp; = cn\lg{n} - cn + n&amp;\\ &amp; \leq cn\lg{n} ~ \text{holds for} ~ c \geq 1 \end{flalign}\] <p>This looks good for the recurrence, i.e. the inductive step. But we also have to show the inequality holds for the base cases, i.e. for \(c\) and \(n_0\). Notice if we choose \(n_0 = 1\) as the base case, our recurrence says \(T(1) = 2\lfloor{1/2}\rfloor + 1 = 1\), but the inequality says \(T(1) \leq c1\lg{1} = 0\), a contradiction!</p> <p>Luckily, we can remove the troublesome \(n = 1\) base case from the inductive proof. It’s still the base case of the recurrence, but intuitively we don’t need to recurse on an array containing a single element because it is already “sorted”. We set \(T(1)\) = 1, and look for other base cases to use in the inductive proof.</p> <p>Observe that \(T(n)\) does not directly depend on \(T(1)\) for \(n &gt; 3\). Using \(T(1) = 1\), we find that \(T(2) = 4\) and \(T(3) = 5\). We can use these as the base cases in the inductive proof by setting \(n_0 = 2\). Now we just need to find a value for \(c\) so that \(T(2) \leq c2\lg{2}\) and \(T(3) \leq c3\lg{3}\). It turns out any \(c \geq 2\) is sufficient.<d-cite key="clrs2009"></d-cite></p> <p>This was an example of the <strong>substitution method</strong> for solving recurrences:</p> <ol> <li>Guess the form of the solution.</li> <li>Use mathematical induction to find \(c\) and \(n_0\) showing the solution works.</li> </ol> <h2 id="recursion-trees">Recursion Trees</h2> <p>Another way to see that merge sort is \(O(n \log n)\) is by looking at its <strong>recursion tree</strong>. That is, a rooted tree where each node represents a subproblem, and has a value corresponding to its contribution to the overall running time. The root of the tree represents the original problem. Edges represent recursive calls to other subproblems, and do <em>not</em> contribute to the running time of either of their endpoints. Leaves represent base cases. The overall running time can therefore be thought of as the sum of node values.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/recursion-tree-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/recursion-tree-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/recursion-tree-1400.webp"/> <img src="/assets/img/recursion-tree.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> The first three levels of the recursion tree for merge sort. </div> <p>The value of each node comes from the <em>nonrecursive</em> work done for that subproblem. One can see the root value \(n\) comes from the \(\Theta(n)\) in the recurrence:</p> <p>\(MergeSort(n) = 2MergeSort(n/2) + \Theta(n)\).</p> <p>The \(2\) edges from the root are because \(MergeSort(n)\) makes \(2\) recursive calls, and the value of the children of the root \(n/2\) comes from the \(\Theta(n/2)\) in \(MergeSort(n/2)\). Let \(d\) be some depth within the tree, starting with \(d = 0\) at the root. In general, there are \(2^d\) nodes at each depth or level of the tree, and each node at that level has a value of \(n/2^d\).</p> <p>Since we’re talking specifically about merge sort, and because it doesn’t actually affect the asymptotic bounds, let the base case of the recurrence be \(T(1) = 1\). As stated earlier, \(T(n)\) is equal to the sum of all node values in the tree. Suppose there are \(L\) levels in the entire tree, so there are \(2^L\) leaves with value \(n/2^L\). Since the leaves are base cases, we know \(n/2^L = 1\), which tells us the number of levels in the tree \(L = \lg{n}\).</p> <p>There is one more key fact that allows us to determine the running time: the sum of node values at each level of the tree is \(n\). Putting it all together, the recursion tree consists of \(\lg{n}\) levels that each contribute \(n\) time, so the overall running time of \(T(n)\) is \(O(n \lg n)\).</p> <p>In general, there are many recurrences of the form \(T(n) = r~T(n/c) + f(n)\) with \(\Theta(1)\) base cases. The example we just saw had \(r = c = 2,\) and \(f(n) = n\). So, a recursion tree for this general recurrence is a complete \(r\)-ary tree where each node at depth \(d\) has value \(f(n/c^d)\). The running time is the level-by-level sum of node values:</p> <p>\(T(n) = \sum\limits_{i = 0}^{L}{r^i \cdot f(n/c^i)}\).</p> <p>We saw that \(L = \log_c{n}\) when \(n_0 = 1\) because \(n/c^L = n_0\) is the base case. We also saw there are exactly \(r^L = r^{\log_c{n}} = n^{\log_c{r}}\) leaves. The last key fact was really that the values of the leaves sum to \(n^{\log_c{r}} \cdot \Theta(1) = \Theta(n^{\log_c{r}})\).<d-cite key="fox2023"></d-cite></p> <p>The sum we just saw is a <a href="https://en.wikipedia.org/wiki/Geometric_series">geometric series</a>, whose asymptotic growth is given by the largest term in the series. With this in mind, there are three common cases where the sum is actually easy to evaluate:</p> <ol> <li><strong>Decreasing</strong>: if every term in the series is a constant factor smaller than the previous term, then the running time is dominated by the value at the root of the tree, and \(T(n) = \Theta(f(n))\).</li> <li><strong>Equal</strong>: if all terms in the series are equal, then \(T(n) = \Theta(f(n) \log{n})\). Merge sort falls under this case.</li> <li><strong>Increasing</strong>: if every term in the series is a constant factor larger than the previous term, then the running time is dominated by the sum of leaf values, so \(T(n) = \Theta(n^{\log_c{n}})\).</li> </ol>]]></content><author><name>Nicholas Colvin</name></author><category term="algorithms"/><category term="math"/><summary type="html"><![CDATA[an introduction to solving problems recursively]]></summary></entry></feed>