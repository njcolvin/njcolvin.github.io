<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://njcolvin.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://njcolvin.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-09-16T23:03:31+00:00</updated><id>https://njcolvin.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Recursion</title><link href="https://njcolvin.github.io/blog/2023/divide-and-conquer/" rel="alternate" type="text/html" title="Recursion"/><published>2023-03-05T00:00:00+00:00</published><updated>2023-03-05T00:00:00+00:00</updated><id>https://njcolvin.github.io/blog/2023/divide-and-conquer</id><content type="html" xml:base="https://njcolvin.github.io/blog/2023/divide-and-conquer/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>This note assumes you know what an algorithm is, but as a quick refresher according to Jeff Erickson, “an algorithm is an explicit, precise, unambiguous, mechanically-executable sequence of elementary instructions, usually intended to accomplish a specific purpose.”<d-cite key="erickson2019Algos"></d-cite></p> <p>Good algorithms are incredibly useful, but sometimes a problem might not have a clear algorithmic solution. Worse, it might even be <a href="https://en.wikipedia.org/wiki/Undecidable_problem">impossible</a>. A powerful method to solve an unknown problem is to make a <strong>reduction</strong> to one or more simpler problems that can be solved by known algorithms. The reduction of a problem can even be into smaller instances of itself, breaking up repeatedly until reaching one of several base cases. This is called <strong>recursion</strong>. Divide-and-conquer is a general pattern for solving a problem using recursion:</p> <ol> <li><strong>Divide</strong> the problem into independent smaller instances of the same problem.</li> <li><strong>Conquer</strong> or solve the smaller instances by recursion.</li> <li><strong>Combine</strong> the solutions of the smaller instances into a solution of the original problem.</li> </ol> <p>It is often easier to think of recursion without thinking about solving the smaller subproblems yourself. Instead, think of a worker solving all of the subproblems for you. You must know how to relate the problem to smaller versions of itself, and how to solve any of the smallest instances that can no longer be simplified. Once you simplify the original problem, hand the subproblems off to the worker. They will simplify and solve the subproblems for you, so let them work in peace.</p> <p>A natural way to characterize the running time of a divide-and-conquer algorithm is to use a <strong>recurrence</strong>, or a function defined in terms of itself. So far we have been using the words <em>smaller</em> and <em>simpler</em> interchangably. Indeed, in terms of analyzing the running time of an algorithm we often consider the input size, denoted \(n\).</p> <p>As a quick example, consider the following recurrence for merge sort:</p> \[MergeSort(n) = \begin{cases} \Theta(1) &amp; n = 1 \\ 2MergeSort(n/2) + \Theta(n) &amp; otherwise \end{cases}\] <p>Merge sort consists of splitting the unsorted input array into two roughly equal halves, recursively sorting those halves, and then merging the sorted halves into a sorted version of the input array. The recurrence says it takes constant \(\Theta(1)\) time to sort an array with 1 element, or \(2MergeSort(n/2)\) time to sort the halves and linear \(\Theta(n)\) time to merge the halves into a solution. It is well-documented the overall running time is \(\Theta(n \log{n})\).</p> <hr/> <h2 id="the-substitution-method">The Substitution Method</h2> <p>Consider a similar recurrence:</p> \[T(n) = 2T(\lfloor{n/2}\rfloor) + n\] <p>This looks like merge sort, so how can we show \(T(n) = O(n \log{n})\)? Using the definition of <a href="https://en.wikipedia.org/wiki/Big_O_notation">big O</a>, we must show there exist positive constants \(c\) and \(n_0\) such that:</p> \[T(n) \leq cn\lg{n}, \quad n \geq n_0\] <p>To do this, we must assume the above inequality holds for some positive \(m &lt; n\), particularly \(m = \lfloor{n/2}\rfloor\). Plugging this in gives:</p> \[\begin{flalign} T(n) &amp; \leq 2(c\lfloor{n/2}\rfloor\lg{\lfloor{n/2}\rfloor}) + n&amp;\\ &amp; \leq cn\lg{n/2} + n&amp;\\ &amp; = cn\lg{n} - cn\lg{2} + n&amp;\\ &amp; = cn\lg{n} - cn + n&amp;\\ &amp; \leq cn\lg{n} ~ \text{holds for} ~ c \geq 1 \end{flalign}\] <p>This looks good for the recurrence, i.e. the inductive step. But we also have to show the inequality holds for the base cases, i.e. for \(c\) and \(n_0\). Notice if we choose \(n_0 = 1\) as the base case, our recurrence says \(T(1) = 2\lfloor{1/2}\rfloor + 1 = 1\), but the inequality says \(T(1) \leq c1\lg{1} = 0\), a contradiction!</p> <p>Luckily, we can remove the troublesome \(n = 1\) base case from the inductive proof (it is still part of the recurrence, though). Observe that \(T(n)\) does not depend on \(T(1)\) for \(n &gt; 3\). We can replace \(T(1)\) with \(T(2)\) and \(T(3)\) as the base cases in the inductive proof by setting \(n_0 = 2\). Now we just need to find a value for \(c\) so that \(T(2) \leq c2\lg{2}\) and \(T(3) \leq c3\lg{3}\). Any \(c \geq 2\) is sufficient.<d-cite key="clrs2009"></d-cite></p> <p>This was an example of the <strong>substitution method</strong> for solving recurrences:</p> <ol> <li>Guess the form of the solution.</li> <li>Use mathematical induction to find \(c\) and \(n_0\) showing the solution works.</li> </ol>]]></content><author><name>Nicholas Colvin</name></author><category term="algorithms"/><category term="math"/><summary type="html"><![CDATA[an introduction to solving problems recursively]]></summary></entry></feed>